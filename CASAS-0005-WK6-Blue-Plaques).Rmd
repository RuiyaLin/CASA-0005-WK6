---
title: "WK6 Detecting Spatial Patterns (Blue Plaques)"
output: html_notebook
---

#### 这是一个R Markdown笔记本。在笔记本中执行代码时，结果会显示在代码下方。
#### 尝试通过点击代码块中的 运行 按钮，或将光标放在代码块内并按 Cmd+Shift+Enter 来执行此代码块。
#### 通过点击工具栏上的 插入代码块 按钮或按 Cmd+Option+I 来插入一个新的代码块。
#### 当你保存笔记本时，包含代码和输出的 HTML 文件将与笔记本一起保存（点击 预览 按钮或按 Cmd+Shift+K 来预览 HTML 文件）。
#### 预览会显示编辑器内容的渲染 HTML 副本。因此，与 编织（Knit）不同，预览 不会运行任何 R 代码块。相反，它显示的是代码块在编辑器中最后一次运行时的输出。

# Chapter 6 Detecting Spatial Patterns (Blue Plaques)
## Research Questions
### For any given London Borough, are the Blue Plaques within that borough distributed randomly or do they exhibit some kind of dispersed or clustered pattern?”

## 6.1. Import libraries 
```{r}
install.packages("spatstat")
library(spatstat)
library(here)
library(sp)
library(tmap)
library(sf)
library(tmaptools)
```

## 6.2. Setting up your data 
### Read Spatial data (RF1)
```{r}
LondonBoroughs <- st_read(here::here("Data", "Spatial data","London_Borough_Excluding_MHW.shp"))
```
### Pull out London: str_detect() -->RF2
```{r}
library(stringr)
BoroughMap <- LondonBoroughs %>%
  dplyr::filter(str_detect(GSS_CODE, "^E09"))%>%
  st_transform(., 27700)
```
#### Quick map 
```{r}
qtm(BoroughMap)
#### Check RF2
summary(BoroughMap)
```
### Read data about Blue Plaques (DF3)
```{r}
BluePlaques <- st_read("https://s3.eu-west-2.amazonaws.com/openplaques/open-plaques-london-2018-04-08.geojson") %>%
  st_transform(.,27700)
```
#### Check the data
```{r}
summary(BluePlaques)
```
#### Plot the blue plaques in the city 
```{r}
tmap_mode("plot")
tm_shape(BoroughMap) +
  tm_polygons(col = NA, alpha = 0.5) +
  tm_shape(BluePlaques) +
  tm_dots(col = "blue")
```

## 6.3. Data Cleaning 
#### 将边界外的点移回来并删除重复的数据
### Remove duplicates
```{r}
library(tidyverse)
library(sf)
BluePlaques <- distinct(BluePlaques)
```

### Spatial subsetting 
```{r}
BluePlaquesSub <- BluePlaques[BoroughMap,]
```
#### check to see that they've been removed (plot again)
```{r}
tmap_mode("plot")
tm_shape(BoroughMap) +
  tm_polygons(col = NA, alpha = 0.5) +
  tm_shape(BluePlaquesSub) +
  tm_dots(col = "blue")
```
##### 當我們像這樣的空間子集數據時，我們可以指定不同的拓撲關係。預設值為 intersects，但我們也可以使用 BluePlaquesSub <- BluePlaques[BoroughMap, , op = st_within] ，並將運算符或操作設置為 st_within ，以識別完全位於行政區輪廓內的點，或者使用各種其他選項，例如 st_overlaps 、 st_touches st_contains st_disjoint 。您能想到的函數的任何可能的拓撲關係都會為它存在......視覺上這看起來像......其中，每個刻度表示應用於多邊形的關係。請注意，在幾種情況下，多個拓撲關係是可行的。
##### Select points or polygons in a polygon = Selecting data by location = spatial sub-setting
##### 選擇多邊形中的點或多邊形 = 按位置選擇資料 = 空間子集
#### Determine where datasets overlap (or touch, or don’t overlap) and extract those parts = spatial clipping
##### 確定數據集重疊（或接觸或不重疊）的位置並提取這些部分 = 空間裁剪
##### Join two spatial datasets together = spatial joining, which can use spatial subsetting functions as the default is st_intersects(). This function joins spatial data.
##### 將兩個空間資料集聯接在一起 = 空間聯接 ，可以使用空間子集函數，因為預設值為 st_intersects() 。此函數聯接空間數據。

### Spatial clipping or joining (section 6.5.4. skipped)

### Study area (选择一个行政区进行分析)
#### extract the borough
#### select by attribute
```{r}
Harrow <- BoroughMap %>%
  filter(., NAME=="Harrow")
```
#### Check to see that the correct borough has been pulled out
```{r}
tm_shape(Harrow) +
  tm_polygons(col = NA, alpha = 0.5)
```
#### clip the data to our single borough
```{r}
BluePlaquesSub <- BluePlaques[Harrow,]
```
#### check that it's worked
```{r}
tmap_mode("plot")
```
#### Plot to see it
```{r}
tm_shape(Harrow) +
  tm_polygons(col = NA, alpha = 0.5) +
  tm_shape(BluePlaquesSub) +
  tm_dots(col = "blue")
```
#### Set a window as the borough boundary
```{r}
window <- as.owin(Harrow)
plot(window)
```
#### create a spatial point (sp) object
```{r}
BluePlaquesSub<- BluePlaquesSub %>%
  as(., 'Spatial')
```
#### create a Point Pattern (ppp) object
```{r}
BluePlaquesSub.ppp <- ppp(x=BluePlaquesSub@coords[,1],
                          y=BluePlaquesSub@coords[,2],
                          window=window)
```




